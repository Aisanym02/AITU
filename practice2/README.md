# Цель работы
Целью данной работы является:
реализация последовательных алгоритмов сортировки;
реализация их параллельных версий с использованием OpenMP;
сравнение времени выполнения последовательных и параллельных реализаций;
анализ эффективности параллелизации для алгоритмов со сложностью O(n²).
# Реализованные алгоритмы
## Пузырьковая сортировка (Bubble Sort)
Реализована стандартная последовательная версия пузырьковой сортировки.
Параллельная версия выполнена в виде odd-even transposition sort, которая корректно распараллеливается за счёт чередования чётных и нечётных фаз сравнения элементов.
## Сортировка выбором (Selection Sort)
Последовательная версия реализована классическим способом.
В параллельной версии внешний цикл остаётся последовательным, однако поиск минимального элемента на каждом шаге выполняется параллельно с использованием локальных минимумов и их объединения.
## Сортировка вставками (Insertion Sort)
Последовательная версия реализована стандартно.
Параллельная версия выполнена с использованием блочного подхода: массив делится на несколько частей, каждая из которых сортируется параллельно, после чего отсортированные блоки последовательно сливаются.
Последовательные и параллельные версии
Для каждого алгоритма реализованы:
последовательная версия без использования OpenMP;
параллельная версия с использованием директив OpenMP (parallel for, critical и др.).
Это позволяет наглядно сравнить влияние параллелизации на производительность.
Тестирование и сравнение производительности
Тестирование проводилось на массивах следующих размеров:
1 000 элементов;
10 000 элементов;
100 000 элементов.
Для каждого размера массива измерялось время выполнения сортировки в микросекундах с использованием библиотеки <chrono>.
После выполнения сортировки дополнительно проверялась корректность результата, чтобы убедиться, что массив действительно отсортирован.
Особенности и ограничения
Все реализованные алгоритмы имеют сложность O(n²), поэтому при больших размерах массива время выполнения может быть значительным. В ряде случаев параллельная версия может не давать существенного ускорения из-за накладных расходов на создание потоков и синхронизацию.
Данная работа носит учебный характер и демонстрирует, что не все алгоритмы одинаково хорошо масштабируются при параллельном выполнении.
Используемые технологии
Язык программирования: C++
Параллельное программирование: OpenMP
Измерение времени: <chrono>
Компилятор: g++ / clang++ с поддержкой OpenMP

#Выводы
В результате выполнения задания было показано, что параллелизация алгоритмов со сложностью O(n²) не всегда 
приводит к значительному ускорению. В некоторых случаях выигрыш во времени ограничен или отсутствует из-за 
накладных расходов. Тем не менее, работа позволяет на практике изучить базовые приёмы использования OpenMP и 
принципы параллельного программирования.


